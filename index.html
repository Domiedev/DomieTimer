<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Domie's Timer</title>
    <style>
        body {
            font-family: sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding-top: 50px;
            background-color: #f4f4f4;
        }
        #timerDisplay {
            font-size: 3em;
            margin-bottom: 20px;
            color: #333;
        }
        .admin-panel {
            margin-top: 30px;
            padding: 20px;
            border: 1px solid #ccc;
            border-radius: 8px;
            background-color: #fff;
            display: flex;
            flex-direction: column;
            gap: 15px; /* Abstand zwischen Elementen */
            align-items: center; /* Zentriert Elemente horizontal */
            width: 300px; /* Feste Breite für das Panel */
            box-sizing: border-box;
        }
         .admin-panel label,
         .admin-panel input,
         .admin-panel button {
             padding: 8px;
             font-size: 1em;
             margin: 2px; /* Kleiner Rand */
         }
         .password-section input {
             width: 120px;
         }
         #adminControls {
             /* display: none; Wird jetzt über JS gesteuert */
             display: flex;
             flex-direction: column;
             gap: 15px;
             align-items: center;
             width: 100%; /* Nimmt die Breite des Panels ein */
         }
         #adminControls label{
            display: inline-block;
            width: 60px; /* Feste Breite für Label */
            text-align: right;
            margin-right: 5px;
         }
         #adminControls input {
             width: 80px;
             text-align: center;
         }
        .button-group {
            display: flex;
            gap: 10px; /* Abstand zwischen Buttons */
            justify-content: center; /* Buttons zentrieren */
            width: 100%;
        }
        #status {
            margin-top: 15px;
            font-style: italic;
            color: green;
            min-height: 1.2em; /* Platz reservieren */
        }
         #errorStatus {
             margin-top: 5px; /* Näher an den Status */
             font-style: italic;
             color: red;
             min-height: 1.2em; /* Platz reservieren */
         }
    </style>
</head>
<body>

    <h1>How long does domie need?</h1>
    <div id="timerDisplay">0m 0s</div>

    <div class="admin-panel">
        <div class="password-section">
             <label for="password">Passwort:</label>
             <input type="password" id="password" placeholder="Passwort">
             <button id="loginBtn">Anmelden</button>
         </div>

         <div id="adminControls" style="display: none;">
             <div>
                 <label for="minutes">Minuten:</label>
                 <input type="number" id="minutes" placeholder="z.B. 20">
                 <button id="setTimerBtn">Setzen</button>
             </div>
             <div class="button-group">
                <button id="add5MinBtn">+5 Min</button>
                <button id="clearTimerBtn">Clear</button>
             </div>
         </div>

         <div id="status"></div>
         <div id="errorStatus"></div>
    </div>

    <script>
        // --- Konfiguration ---
        const JSONBIN_ID = '680411228561e97a50033b62'; // Deine Bin ID

        // !!! ERSETZE 'SETZTE_MASTER' MIT DEINEM ECHTEN (!) JSONBIN MASTER KEY !!!
        // !!! ACHTUNG: Dieser Schlüssel ist im Quellcode sichtbar! Unsicher! !!!
        const JSONBIN_API_KEY = '$2a$10$c4cqsrgXiejCDzbW9dT8heTgh3yBVNAFapRs1xOpr3KyoxzVDS6p.'; // <--- HIER DEINEN ECHTEN MASTER KEY EINFÜGEN

        // !!! ERSETZE 'SETZE_ACCESS' MIT DEINEM ECHTEN (!) JSONBIN ACCESS KEY !!!
        // Wird für das Lesen benötigt (zuverlässiger als ohne)
        const JSONBIN_ACCESS_KEY = '$2a$10$aQg8aZf3yeI12bivdcAi7Odw6uen8Ctp5ZJ4H/u6pAhqjgCeH61k6'; // <--- HIER DEINEN ECHTEN ACCESS KEY EINFÜGEN

        const ADMIN_PASSWORD = '1234'; // Dein Passwort (kannst du ändern)
        // --- Ende Konfiguration ---

        const BIN_URL = `https://api.jsonbin.io/v3/b/${JSONBIN_ID}`;
        const BIN_URL_LATEST = `${BIN_URL}/latest`;

        // DOM Elemente
        const timerDisplay = document.getElementById('timerDisplay');
        const passwordInput = document.getElementById('password');
        const loginBtn = document.getElementById('loginBtn');
        const adminControlsDiv = document.getElementById('adminControls');
        const minutesInput = document.getElementById('minutes');
        const setTimerBtn = document.getElementById('setTimerBtn');
        const add5MinBtn = document.getElementById('add5MinBtn');
        const clearTimerBtn = document.getElementById('clearTimerBtn');
        const statusDiv = document.getElementById('status');
        const errorStatusDiv = document.getElementById('errorStatus');

        let timerInterval = null;
        let currentEndTimestamp = 0; // Wichtig: Globaler Zustand des aktuellen Timers

        // Funktion zum Formatieren der Zeit
        function formatTime(ms) {
            if (ms <= 0) return '0m 0s';
            const totalSeconds = Math.max(0, Math.floor(ms / 1000));
            const minutes = Math.floor(totalSeconds / 60);
            const seconds = totalSeconds % 60;
            return `${minutes}m ${seconds}s`;
        }

        // Funktion zum Updaten der Anzeige
        function updateTimer() {
            const now = Date.now();
            // Nutzt den globalen currentEndTimestamp
            const remainingMs = Math.max(0, currentEndTimestamp - now);
            timerDisplay.textContent = formatTime(remainingMs);
            if (remainingMs <= 0) {
                clearInterval(timerInterval);
                timerInterval = null;
                timerDisplay.textContent = '0m 0s';
            }
        }

        // Startet den visuellen Timer (setzt auch globalen Zeitstempel)
        function startTimerVisuals(endTs) {
            // Setzt den globalen Zeitstempel, auf den sich updateTimer verlässt
            currentEndTimestamp = typeof endTs === 'number' ? endTs : 0;
            console.log(`Setting currentEndTimestamp to: ${currentEndTimestamp}`); // Debug Log

            clearInterval(timerInterval); // Alten Timer löschen
            timerInterval = null;

            const remainingMs = Math.max(0, currentEndTimestamp - Date.now());
            if (remainingMs > 0) {
                updateTimer(); // Sofort anzeigen
                timerInterval = setInterval(updateTimer, 1000); // Neuen Timer starten
            } else {
                timerDisplay.textContent = '0m 0s'; // Direkt auf 0 setzen
            }
        }

       // Funktion zum Abrufen des Timers von JSONBin (Angepasst für Polling)
        async function fetchTimerData(isPolling = false) {
            // Nur beim initialen Laden oder bei Fehlern Status/Fehler zurücksetzen
            if (!isPolling) {
                statusDiv.textContent = 'Lade Timer...';
                errorStatusDiv.textContent = '';
            } else {
                // Bei Polling nur Fehler zurücksetzen, nicht den Status
                 errorStatusDiv.textContent = '';
            }

            // Prüfe ob Access Key Platzhalter ist
            if (!JSONBIN_ACCESS_KEY || JSONBIN_ACCESS_KEY === 'SETZE_ACCESS') {
                errorStatusDiv.textContent = 'Fehler: JSONBin Access Key nicht konfiguriert!';
                console.error('Fehler: JSONBin Access Key nicht konfiguriert!');
                if(!isPolling) startTimerVisuals(0);
                statusDiv.textContent = '';
                return;
            }

            try {
                const response = await fetch(BIN_URL_LATEST, {
                    method: 'GET',
                    headers: {
                        'X-Access-Key': JSONBIN_ACCESS_KEY,
                        'Cache-Control': 'no-cache', // Versuchen Caching zu verhindern
                         'Pragma': 'no-cache'        // Älterer Header für Caching-Verhinderung
                    }
                });

                // Fehler beim Fetch selbst behandeln
                if (!response.ok && response.status !== 304) { // 304 ist kein Fehler, heißt "Nicht geändert"
                    let errorBody = '';
                    try { errorBody = await response.text(); } catch (e) {}
                     if (!isPolling) { // Fehler nur initial prominent anzeigen
                         console.error(`HTTP Fehler beim Laden: ${response.status} - ${response.statusText}. Body: ${errorBody}`);
                         errorStatusDiv.textContent = `Fehler ${response.status} beim Laden. Timer läuft evtl. weiter.`;
                         startTimerVisuals(0); // Initial Timer resetten
                     } else {
                         console.warn(`Polling HTTP Fehler: ${response.status}`);
                         // Bei Polling Fehler nicht prominent anzeigen & Timer weiterlaufen lassen
                     }
                     statusDiv.textContent = '';
                     return; // Funktion verlassen bei Fehler
                }

                // Nur wenn Status OK (200), Body lesen und verarbeiten.
                if (response.status === 200) {
                     const data = await response.json();
                     console.log("Received data structure from JSONBin:", JSON.stringify(data, null, 2));

                     let fetchedEndTimestamp = -1; // Standard ungültiger Wert

                     if (data && data.record && data.record.record && typeof data.record.record.endTimestamp === 'number') {
                         fetchedEndTimestamp = data.record.record.endTimestamp;
                     } else {
                         // Ungültige Struktur empfangen
                         if (!isPolling) {
                             errorStatusDiv.textContent = 'Timer-Daten empfangen, aber Struktur nicht wie erwartet. Setze auf 0.';
                             console.error("Unerwartete oder ungültige Datenstruktur:", data);
                             startTimerVisuals(0);
                         } else {
                             console.warn("Polling: Received unexpected data structure:", data);
                         }
                          statusDiv.textContent = '';
                          return;
                     }

                     // --- Vergleichslogik ---
                     // Nur neu starten, wenn Zeitstempel sich geändert hat
                     if (fetchedEndTimestamp !== currentEndTimestamp) {
                         console.log(`Timestamp changed via fetch. Old: ${currentEndTimestamp}, New: ${fetchedEndTimestamp}. Restarting visuals.`);
                         startTimerVisuals(fetchedEndTimestamp); // Aktualisiert globalen Timestamp und startet Timer neu
                     } else {
                         // Zeitstempel nicht geändert, Log für Debugging beim Polling
                         if(isPolling) console.log("Polling: Timestamp unchanged.");
                     }

                     // Lade-Status nur beim initialen erfolgreichen Laden entfernen
                     if (!isPolling) {
                         statusDiv.textContent = '';
                     }
                 } else if (response.status === 304) {
                      // 304 Not Modified - alles ok, Daten haben sich nicht geändert
                      if(isPolling) console.log("Polling: Data not modified (304).");
                 }

            } catch (error) { // Catch für Netzwerkfehler etc.
                 if (!isPolling) {
                    console.error('Fehler beim Abrufen des Timers:', error);
                    errorStatusDiv.textContent = `Fehler beim Laden: ${error.message}. Zeige 0m 0s.`;
                    startTimerVisuals(0);
                    statusDiv.textContent = '';
                 } else {
                      console.warn("Polling: Network or other error fetching timer:", error.message);
                 }
            }
        }


        // Funktion zum Schreiben des Timers nach JSONBin
        async function updateJsonBin(newEndTimestamp) {
             // Prüfe ob Master Key Platzhalter ist
             if (!JSONBIN_API_KEY || JSONBIN_API_KEY === 'SETZTE_MASTER') {
                errorStatusDiv.textContent = 'Fehler: JSONBin Master Key nicht konfiguriert (Platzhalter SETZTE_MASTER gefunden)!';
                console.error('Fehler: JSONBin Master Key nicht konfiguriert (Platzhalter SETZTE_MASTER gefunden)!');
                alert('Fehler: JSONBin Master Key nicht konfiguriert (Platzhalter SETZTE_MASTER gefunden)!');
                return false;
             }
             statusDiv.textContent = 'Speichere Timer...';
             errorStatusDiv.textContent = '';
             const timestampToSend = typeof newEndTimestamp === 'number' ? newEndTimestamp : 0;
             const dataToSend = { record: { endTimestamp: timestampToSend } };

            try {
                const response = await fetch(BIN_URL, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-Master-Key': JSONBIN_API_KEY // ACHTUNG: Unsicher!
                    },
                    body: JSON.stringify(dataToSend)
                });
                if (!response.ok) {
                    let errorBody = '';
                    try { errorBody = await response.text(); } catch(e) {}
                    if (response.status === 401) {
                         errorBody += ' (Ist der Master Key korrekt und der Bin gehört zum Account?)';
                    }
                    throw new Error(`HTTP Fehler: ${response.status} - ${response.statusText}. Body: ${errorBody}`);
                }
                statusDiv.textContent = 'Timer erfolgreich gespeichert!';
                // Nach erfolgreichem Speichern *sofort* neu laden (die korrigierte fetch Funktion wird verwendet)
                // Das stellt sicher, dass auch der *aktualisierende Client* den neuen Wert korrekt anzeigt
                // Der Polling Mechanismus aktualisiert dann die anderen Clients
                await fetchTimerData(false); // false, damit es als normale Aktualisierung gilt
                return true;
            } catch (error) {
                console.error('Fehler beim Speichern des Timers:', error);
                errorStatusDiv.textContent = `Fehler beim Speichern: ${error.message}`;
                statusDiv.textContent = '';
                return false;
            } finally {
                 setTimeout(() => {
                     if (statusDiv.textContent === 'Timer erfolgreich gespeichert!') {
                         statusDiv.textContent = '';
                     }
                 }, 3000);
             }
        }

        // --- Event Listener ---

        // Login Button
        loginBtn.addEventListener('click', () => {
            const enteredPassword = passwordInput.value;
            if (enteredPassword === ADMIN_PASSWORD) {
                adminControlsDiv.style.display = 'flex';
                passwordInput.disabled = true;
                loginBtn.disabled = true;
                errorStatusDiv.textContent = '';
                statusDiv.textContent = 'Angemeldet.';
                 setTimeout(() => { statusDiv.textContent = ''; }, 2000);
            } else {
                errorStatusDiv.textContent = 'Falsches Passwort!';
                passwordInput.value = '';
                adminControlsDiv.style.display = 'none';
            }
        });

        // Timer setzen Button
        setTimerBtn.addEventListener('click', async () => {
            const minutes = parseInt(minutesInput.value, 10);
            if (isNaN(minutes) || minutes < 0) {
                errorStatusDiv.textContent = 'Bitte eine gültige positive Minutenzahl eingeben.';
                 statusDiv.textContent = '';
                return;
            }
            errorStatusDiv.textContent = '';
            const now = Date.now();
            const newEndTimestamp = now + minutes * 60 * 1000;
            const success = await updateJsonBin(newEndTimestamp);
             if (success) {
                 minutesInput.value = '';
             }
        });

        // Clear Timer Button
        clearTimerBtn.addEventListener('click', async () => {
             errorStatusDiv.textContent = '';
            await updateJsonBin(0);
        });

        // +5 Minuten Button
        add5MinBtn.addEventListener('click', async () => {
             statusDiv.textContent = 'Füge 5 Minuten hinzu...';
             errorStatusDiv.textContent = '';
              // Prüfe ob Access Key konfiguriert ist bevor wir lesen
              if (!JSONBIN_ACCESS_KEY || JSONBIN_ACCESS_KEY === 'SETZE_ACCESS') {
                 errorStatusDiv.textContent = 'Fehler: Access Key fehlt für +5 Min Funktion.';
                 statusDiv.textContent = '';
                 return;
              }
            try {
                 // Rufe fetchTimerData auf, um sicherzustellen, dass 'currentEndTimestamp' aktuell ist
                 // Die Funktion selbst prüft, ob sie den visuellen Timer neu starten muss.
                 await fetchTimerData(false); // false, da dies eine explizite Aktion ist

                 // Prüfen ob Laden erfolgreich war (errorStatusDiv wäre gesetzt wenn nicht)
                 if(errorStatusDiv.textContent){
                      statusDiv.textContent = ''; // 'Füge hinzu' Meldung entfernen
                      // Fehler wurde bereits in fetchTimerData angezeigt
                      return;
                 }

                 const now = Date.now();
                 // Verwende den globalen currentEndTimestamp, der von fetchTimerData korrekt gesetzt wurde
                 const baseTimestamp = Math.max(now, currentEndTimestamp);
                 const newEndTimestamp = baseTimestamp + 5 * 60 * 1000;

                 // Speichere den neuen Wert. updateJsonBin ruft fetchTimerData erneut auf.
                 await updateJsonBin(newEndTimestamp);

             } catch (error) {
                 // Dieser Catch ist unwahrscheinlich, da Fehler in fetch/update behandelt werden sollten
                 console.error("Fehler bei +5 Min Logik:", error);
                 errorStatusDiv.textContent = `Fehler bei +5 Min: ${error.message}`;
                 statusDiv.textContent = '';
             }
        });

        // --- Initialisierung ---
        fetchTimerData(); // Timer beim Laden der Seite holen (verwendet die korrigierte Funktion)

        // --- Polling starten ---
        const POLLING_INTERVAL_MS = 15000; // Alle 15 Sekunden nachfragen (15000ms)
        console.log(`Starting polling every ${POLLING_INTERVAL_MS / 1000} seconds.`);
        setInterval(() => {
            // console.log("Polling for timer update..."); // Kann man auskommentieren wenn es stört
            fetchTimerData(true); // true signalisiert, dass es ein Polling-Aufruf ist
        }, POLLING_INTERVAL_MS);

    </script>

</body>
</html>
